<?xml version="1.0" encoding="UTF-8"?>
<!--
Story Context: Backend Integration + Database Schema + AI Crew Generation
Story ID: 1-1-backend-integration-database-schema-ai-crew-generation
Epic: Epic 1 - FieldPay-Pro P4P Integration
Generated: 2025-11-19
-->

<story-context>
  <metadata>
    <story-id>1-1-backend-integration-database-schema-ai-crew-generation</story-id>
    <story-title>Backend Integration + Database Schema + AI Crew Generation</story-title>
    <epic-id>epic-1</epic-id>
    <epic-title>FieldPay-Pro P4P Integration</epic-title>
    <status>ready-for-dev</status>
    <effort-points>3</effort-points>
    <estimated-days>1.5</estimated-days>
    <prerequisites>None (foundation story)</prerequisites>
    <dependencies>
      <dependency type="external">Firebase Authentication (existing)</dependency>
      <dependency type="external">Supabase PostgreSQL (new instance required)</dependency>
      <dependency type="external">OpenAI API (for crew generation)</dependency>
    </dependencies>
  </metadata>

  <overview>
    <summary>
      Establish the foundational backend infrastructure for the FieldPay-Pro P4P payroll integration.
      Create a new Express TypeScript server alongside the existing React frontend, using Firebase Admin SDK
      for authentication (validating tokens from Firebase Auth) and Supabase PostgreSQL for payroll data storage.
      The dual-database architecture separates concerns: Firebase Firestore remains for project/BOM data,
      while Supabase handles payroll-specific tables.
    </summary>
    <business-value>
      - Foundation for complete end-to-end construction management platform
      - Enables labor cost tracking and profitability analysis
      - Supports 4+ hours/day payroll automation in future stories
      - Demo crew generation enables immediate testing and demonstrations
    </business-value>
    <technical-approach>
      Express 4.18.2 backend with TypeScript, Firebase Admin SDK for JWT validation, Supabase PostgreSQL
      for relational payroll data, AI-powered demo crew generation using OpenAI structured output.
    </technical-approach>
  </overview>

  <user-stories>
    <user-story role="system administrator">
      I want to set up the Express backend with Firebase Admin SDK, Supabase, and generate demo crews,
      So that the foundation is ready for payroll, crew management, and time tracking features.
    </user-story>
  </user-stories>

  <acceptance-criteria>
    <criterion id="AC1">
      <title>Express server starts successfully on port 3000</title>
      <given>backend dependencies are installed</given>
      <when>I run `npm run dev` in backend directory</when>
      <then>server starts without errors and logs "Server running on port 3000"</then>
    </criterion>
    <criterion id="AC2">
      <title>Health check endpoints return 200 OK</title>
      <given>server is running</given>
      <when>I call GET /api/health</when>
      <then>response is {"status":"ok","timestamp":"..."}</then>
      <and>GET /api/health/db returns {"firebase":"connected","supabase":"connected"}</and>
    </criterion>
    <criterion id="AC3">
      <title>Database migrations create all required tables</title>
      <given>Supabase credentials are configured</given>
      <when>I run `npm run db:migrate`</when>
      <then>7 tables are created: crews, project_crew_assignments, labor_estimates, cpm_tasks, timesheets, payroll_records, profitability_metrics</then>
      <and>indexes are created on foreign keys and date columns</and>
    </criterion>
    <criterion id="AC4">
      <title>Auth middleware validates Firebase tokens</title>
      <given>protected endpoint exists</given>
      <when>I call endpoint without Authorization header</when>
      <then>response is 401 Unauthorized</then>
      <and>with valid Firebase token, response is 200 OK</and>
    </criterion>
    <criterion id="AC5">
      <title>RBAC middleware enforces role permissions</title>
      <given>endpoint requires "admin" role</given>
      <when>I call endpoint with "crew_member" token</when>
      <then>response is 403 Forbidden</then>
      <and>with "admin" token, response is 200 OK</and>
    </criterion>
    <criterion id="AC6">
      <title>AI generates 3 demo crews with 9 workers</title>
      <given>OpenAI API is configured</given>
      <when>I run `npm run generate:demo-crews`</when>
      <then>3 crews are created in database</then>
      <and>each crew has 1 foreman and 2 crew members</and>
      <and>all workers have realistic names, roles, and base rates</and>
    </criterion>
  </acceptance-criteria>

  <technical-context>
    <architecture>
      <pattern>Dual-Database Architecture</pattern>
      <description>
        Firebase Firestore for existing project/BOM data (real-time, document-based)
        + Supabase PostgreSQL for payroll data (ACID compliance, complex queries).
        Express backend validates Firebase JWT tokens and queries both databases.
      </description>
      <components>
        <component name="Express Server" path="backend/src/server.ts">
          Entry point for REST API, handles CORS, error handling, request logging
        </component>
        <component name="Firebase Admin SDK" path="backend/src/config/firebase.ts">
          Server-side Firebase client for JWT token verification (no direct auth)
        </component>
        <component name="Supabase Client" path="backend/src/config/supabase.ts">
          PostgreSQL client for payroll database operations
        </component>
        <component name="Auth Middleware" path="backend/src/middleware/auth.ts">
          Validates Firebase tokens on every protected route
        </component>
        <component name="RBAC Middleware" path="backend/src/middleware/rbac.ts">
          Enforces role-based permissions (admin, manager, foreman, crew_member)
        </component>
        <component name="Health Check Routes" path="backend/src/routes/health.ts">
          Monitoring endpoints for server and database status
        </component>
        <component name="AI Crew Generator" path="backend/src/scripts/generateDemoCrews.ts">
          Uses OpenAI to create realistic demo crews for testing
        </component>
      </components>
    </architecture>

    <database-schema>
      <table name="crews">
        <description>Crew definitions with foreman assignment</description>
        <columns>
          <column name="id" type="UUID" pk="true">Primary key</column>
          <column name="name" type="TEXT">Crew display name</column>
          <column name="foreman_id" type="UUID">References users table (Firebase UID)</column>
          <column name="created_at" type="TIMESTAMP">Record creation timestamp</column>
        </columns>
      </table>
      <table name="project_crew_assignments">
        <description>Links crews to projects with date ranges</description>
        <columns>
          <column name="id" type="UUID" pk="true">Primary key</column>
          <column name="project_id" type="UUID">Firebase project document ID</column>
          <column name="crew_id" type="UUID">References crews table</column>
          <column name="start_date" type="DATE">Assignment start date</column>
          <column name="end_date" type="DATE">Assignment end date (nullable)</column>
          <column name="status" type="TEXT">active | inactive</column>
          <column name="created_at" type="TIMESTAMP">Record creation timestamp</column>
        </columns>
        <indexes>
          <index columns="project_id, crew_id">Multi-column index for assignment queries</index>
          <index columns="start_date, end_date">Date range index for filtering</index>
        </indexes>
      </table>
      <table name="labor_estimates">
        <description>AI-generated labor cost estimates per project</description>
        <columns>
          <column name="id" type="UUID" pk="true">Primary key</column>
          <column name="project_id" type="UUID">Firebase project document ID</column>
          <column name="estimated_cost" type="DECIMAL(10,2)">Total estimated labor cost</column>
          <column name="estimated_duration" type="INT">Duration in days</column>
          <column name="created_at" type="TIMESTAMP">Record creation timestamp</column>
        </columns>
      </table>
      <table name="cpm_tasks">
        <description>Critical Path Method task breakdown with dependencies</description>
        <columns>
          <column name="id" type="UUID" pk="true">Primary key</column>
          <column name="estimate_id" type="UUID">References labor_estimates</column>
          <column name="task_name" type="TEXT">Task description</column>
          <column name="estimated_hours" type="DECIMAL(5,2)">Hours estimate</column>
          <column name="dependencies" type="TEXT[]">Array of prerequisite task IDs</column>
          <column name="critical_path" type="BOOLEAN">True if on critical path</column>
          <column name="earliest_start" type="INT">ES day offset</column>
          <column name="latest_start" type="INT">LS day offset</column>
          <column name="float" type="INT">Float time (LS - ES)</column>
        </columns>
      </table>
      <table name="timesheets">
        <description>Clock-in/out records per employee per project</description>
        <columns>
          <column name="id" type="UUID" pk="true">Primary key</column>
          <column name="employee_id" type="UUID">Firebase user UID</column>
          <column name="project_id" type="UUID">Firebase project document ID</column>
          <column name="date" type="DATE">Timesheet date</column>
          <column name="clock_in" type="TIMESTAMP">Clock-in timestamp</column>
          <column name="clock_out" type="TIMESTAMP">Clock-out timestamp</column>
          <column name="lunch_duration" type="INT">Lunch minutes</column>
          <column name="created_at" type="TIMESTAMP">Record creation timestamp</column>
        </columns>
        <indexes>
          <index columns="employee_id, date">Employee daily lookup</index>
          <index columns="project_id, date">Project daily lookup</index>
        </indexes>
      </table>
      <table name="payroll_records">
        <description>Calculated payroll with P4P formula results</description>
        <columns>
          <column name="id" type="UUID" pk="true">Primary key</column>
          <column name="employee_id" type="UUID">Firebase user UID</column>
          <column name="date" type="DATE">Payroll date</column>
          <column name="hours_worked" type="DECIMAL(5,2)">Total hours</column>
          <column name="base_rate" type="DECIMAL(10,2)">Hourly rate</column>
          <column name="base_pay" type="DECIMAL(10,2)">hours × rate</column>
          <column name="late_penalty" type="DECIMAL(10,2)">5% penalty if late</column>
          <column name="long_lunch_penalty" type="DECIMAL(10,2)">2% penalty if lunch > 30min</column>
          <column name="total_pay" type="DECIMAL(10,2)">base_pay - penalties</column>
          <column name="status" type="TEXT">calculated | approved | rejected</column>
          <column name="approved" type="BOOLEAN">Admin approval flag</column>
          <column name="approved_by" type="UUID">Approver user UID</column>
          <column name="approved_at" type="TIMESTAMP">Approval timestamp</column>
          <column name="has_anomalies" type="BOOLEAN">Anomaly flag</column>
          <column name="anomaly_flags" type="TEXT[]">Array of anomaly codes</column>
          <column name="created_at" type="TIMESTAMP">Record creation timestamp</column>
        </columns>
        <indexes>
          <index columns="employee_id, date">Employee payroll lookup</index>
          <index columns="status">Status filtering</index>
          <index columns="has_anomalies">Anomaly filtering</index>
        </indexes>
      </table>
      <table name="profitability_metrics">
        <description>Variance tracking: estimated vs actual costs</description>
        <columns>
          <column name="id" type="UUID" pk="true">Primary key</column>
          <column name="project_id" type="UUID">Firebase project document ID</column>
          <column name="estimated_labor" type="DECIMAL(10,2)">Total labor estimate</column>
          <column name="actual_labor" type="DECIMAL(10,2)">Total payroll cost</column>
          <column name="variance" type="DECIMAL(10,2)">estimated - actual</column>
          <column name="margin_percent" type="DECIMAL(5,2)">variance / estimated × 100</column>
          <column name="updated_at" type="TIMESTAMP">Last calculation timestamp</column>
        </columns>
      </table>
    </database-schema>

    <dependencies>
      <backend-dependencies>
        <package name="express" version="^4.18.2">Web framework</package>
        <package name="@types/express" version="latest">TypeScript types for Express</package>
        <package name="cors" version="^2.8.5">CORS middleware</package>
        <package name="dotenv" version="^16.3.1">Environment variable loader</package>
        <package name="firebase-admin" version="^11.11.0">Server-side Firebase SDK</package>
        <package name="@supabase/supabase-js" version="^2.38.4">Supabase PostgreSQL client</package>
        <package name="jsonwebtoken" version="^9.0.2">JWT utilities</package>
        <package name="@types/jsonwebtoken" version="latest">TypeScript types for JWT</package>
      </backend-dependencies>
      <dev-dependencies>
        <package name="typescript" version="~5.9.3">TypeScript compiler</package>
        <package name="@types/node" version="^24.6.0">Node.js types</package>
        <package name="nodemon" version="^3.0.2">Dev server auto-restart</package>
        <package name="jest" version="^29.7.0">Testing framework</package>
        <package name="@types/jest" version="latest">TypeScript types for Jest</package>
        <package name="supertest" version="^7.1.4">HTTP testing</package>
        <package name="@types/supertest" version="latest">TypeScript types for supertest</package>
      </dev-dependencies>
      <existing-frontend-dependencies>
        <note>Frontend uses Vitest for testing, not Jest. Backend will use Jest.</note>
        <package name="vitest" version="^3.2.4">Frontend test framework</package>
        <package name="@testing-library/react" version="^16.3.0">React testing utilities</package>
      </existing-frontend-dependencies>
    </dependencies>

    <environment-variables>
      <variable name="PORT" default="3000">Express server port</variable>
      <variable name="NODE_ENV" default="development">Environment mode</variable>
      <variable name="FIREBASE_PROJECT_ID" required="true">Firebase project ID</variable>
      <variable name="FIREBASE_CLIENT_EMAIL" required="true">Service account email</variable>
      <variable name="FIREBASE_PRIVATE_KEY" required="true">Service account private key</variable>
      <variable name="SUPABASE_URL" required="true">Supabase project URL</variable>
      <variable name="SUPABASE_SERVICE_ROLE_KEY" required="true">Supabase service role key</variable>
      <variable name="OPENAI_API_KEY" required="true">OpenAI API key for crew generation</variable>
    </environment-variables>

    <testing-standards>
      <framework>Jest 29.7.0</framework>
      <test-organization>tests/ directory at backend root</test-organization>
      <assertion-style>expect (Jest default)</assertion-style>
      <mocking>jest.fn(), jest.mock()</mocking>
      <coverage-target>&gt;80% for services</coverage-target>
      <pattern-reference>
        Frontend uses Vitest with describe/it/expect pattern. Backend will use Jest with same pattern.
        Example from frontend: collabcanvas/src/services/firestore.test.ts
      </pattern-reference>
      <test-structure>
        <example>
describe('Auth Middleware', () => {
  it('should reject requests without Authorization header', async () => {
    const mockReq = { headers: {} };
    const mockRes = { status: jest.fn().mockReturnThis(), json: jest.fn() };
    const mockNext = jest.fn();

    await authMiddleware(mockReq, mockRes, mockNext);

    expect(mockRes.status).toHaveBeenCalledWith(401);
    expect(mockNext).not.toHaveBeenCalled();
  });
});
        </example>
      </test-structure>
    </testing-standards>

    <existing-patterns>
      <frontend-service-pattern>
        <location>collabcanvas/src/services/</location>
        <description>
          Service layer pattern with export functions (not classes).
          Use async/await for all async operations.
          Return objects with {success, data, error} pattern.
          Log errors with console.error before throwing.
        </description>
      </frontend-service-pattern>
      <frontend-component-pattern>
        <location>collabcanvas/src/components/</location>
        <description>
          Feature-based folder organization.
          PascalCase for component files.
          Export default component, use named exports for sub-components.
        </description>
      </frontend-component-pattern>
      <frontend-testing-pattern>
        <location>collabcanvas/src/**/*.test.ts</location>
        <description>
          Vitest with describe/it/expect.
          Co-located tests (*.test.ts next to source).
          Mock external dependencies.
          Test edge cases and error handling.
        </description>
      </frontend-testing-pattern>
    </existing-patterns>
  </technical-context>

  <implementation-guide>
    <directory-structure>
      <create>
backend/
├── src/
│   ├── server.ts                # Express server entry point
│   ├── config/
│   │   ├── firebase.ts         # Firebase Admin SDK config
│   │   ├── supabase.ts         # Supabase client config
│   │   └── env.ts              # Environment validation
│   ├── middleware/
│   │   ├── auth.ts             # JWT authentication
│   │   └── rbac.ts             # Role-based access control
│   ├── routes/
│   │   └── health.ts           # Health check endpoints
│   └── scripts/
│       └── generateDemoCrews.ts # AI crew generation
├── database/
│   └── migrations/
│       ├── 001_create_payroll_schema.sql
│       └── 002_create_indexes.sql
├── tests/
│   ├── server.test.ts
│   ├── middleware/
│   │   ├── auth.test.ts
│   │   └── rbac.test.ts
│   └── routes/
│       └── health.test.ts
├── package.json
├── tsconfig.json
├── .env.example
├── .gitignore
└── README.md
      </create>
    </directory-structure>

    <implementation-tasks>
      <task id="1" priority="high" ac="AC1">
        <title>Create backend directory structure</title>
        <steps>
          - Create backend/ directory
          - Initialize npm: npm init -y
          - Install TypeScript: npm install -D typescript @types/node
          - Create tsconfig.json for Node.js
          - Create src/, database/, tests/ folders
        </steps>
      </task>
      <task id="2" priority="high" ac="AC1">
        <title>Set up Express server</title>
        <steps>
          - Install: npm install express cors dotenv
          - Install types: npm install -D @types/express @types/cors
          - Create src/server.ts with Express app
          - Configure CORS for http://localhost:5173 (Vite default)
          - Add error handling middleware
          - Add request logging middleware
          - Export app and start server on PORT (default 3000)
        </steps>
        <reference>tech-spec.md:1685-1695</reference>
      </task>
      <task id="3" priority="high" ac="AC4">
        <title>Configure Firebase Admin SDK</title>
        <steps>
          - Install: npm install firebase-admin
          - Create src/config/firebase.ts
          - Load service account from environment (FIREBASE_PROJECT_ID, FIREBASE_CLIENT_EMAIL, FIREBASE_PRIVATE_KEY)
          - Initialize admin app: admin.initializeApp({credential: admin.credential.cert(serviceAccount)})
          - Export admin.auth() instance
        </steps>
        <reference>tech-spec.md:1685-1695</reference>
      </task>
      <task id="4" priority="high" ac="AC2,AC3">
        <title>Configure Supabase client</title>
        <steps>
          - Install: npm install @supabase/supabase-js
          - Create src/config/supabase.ts
          - Load SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY from environment
          - Create client: createClient(url, key)
          - Export supabase client instance
        </steps>
        <reference>tech-spec.md:1695-1700</reference>
      </task>
      <task id="5" priority="high" ac="AC3">
        <title>Create database migrations</title>
        <steps>
          - Create database/migrations/001_create_payroll_schema.sql
          - Define all 7 tables (crews, project_crew_assignments, labor_estimates, cpm_tasks, timesheets, payroll_records, profitability_metrics)
          - Use UUID for all IDs: uuid_generate_v4()
          - Add foreign key constraints where applicable
          - Create database/migrations/002_create_indexes.sql
          - Add indexes on foreign keys and date columns
          - Create npm script "db:migrate" to run migrations via Supabase CLI or direct SQL execution
        </steps>
        <reference>tech-spec.md:500-540 (database schema)</reference>
      </task>
      <task id="6" priority="high" ac="AC4">
        <title>Implement auth middleware</title>
        <steps>
          - Create src/middleware/auth.ts
          - Extract token from Authorization header (Bearer {token})
          - Verify token: await admin.auth().verifyIdToken(token)
          - Attach decoded user to req.user: {uid, email, ...}
          - Return 401 if token invalid or missing
          - Handle Firebase token expiration errors
        </steps>
        <reference>tech-spec.md:1685-1700</reference>
      </task>
      <task id="7" priority="high" ac="AC5">
        <title>Implement RBAC middleware</title>
        <steps>
          - Create src/middleware/rbac.ts
          - Export requireRole(role: string) middleware factory
          - Check req.user.role from Firebase custom claims (set via Firebase Admin SDK)
          - Return 403 if user role doesn't match required role
          - Support multiple roles: admin, manager, foreman, crew_member
          - Allow role hierarchy: admin can access all, manager can access manager+foreman+crew, etc.
        </steps>
        <reference>tech-spec.md:1420-1435 (RBAC)</reference>
      </task>
      <task id="8" priority="medium" ac="AC6">
        <title>Create AI crew generation script</title>
        <steps>
          - Create src/scripts/generateDemoCrews.ts
          - Define AI prompt: "Generate 3 construction crews. Each crew has 1 foreman and 2 workers. Return JSON with crew name, foreman (name, email, base_rate $40-45/hr), workers (name, email, role, base_rate $22-$35/hr based on role)."
          - Call OpenAI with structured output (JSON schema)
          - Parse response into Crew and Worker objects
          - Insert crews into Supabase crews table
          - Create Firebase Auth users for foreman and workers (or mock user records)
          - Create npm script "generate:demo-crews"
        </steps>
        <reference>tech-spec.md:760-820 (AI crew generation)</reference>
      </task>
      <task id="9" priority="high" ac="AC2">
        <title>Create health check endpoints</title>
        <steps>
          - Create src/routes/health.ts
          - GET /api/health - returns {status: "ok", timestamp: new Date().toISOString()}
          - GET /api/health/db - checks connections:
            - Firebase: try admin.auth().listUsers(1) - catch error if fails
            - Supabase: try supabase.from('crews').select('count') - catch error if fails
            - Return {firebase: "connected"|"error", supabase: "connected"|"error"}
          - Mount routes in server.ts: app.use('/api', healthRoutes)
        </steps>
        <reference>tech-spec.md:1603-1625 (verification endpoints)</reference>
      </task>
      <task id="10" priority="medium" ac="all">
        <title>Write backend tests</title>
        <steps>
          - Install: npm install -D jest @types/jest supertest @types/supertest
          - Configure jest.config.js for TypeScript
          - Create tests/server.test.ts - basic server startup tests
          - Create tests/middleware/auth.test.ts - auth middleware tests (mock Firebase Admin SDK)
          - Create tests/middleware/rbac.test.ts - RBAC tests
          - Create tests/routes/health.test.ts - health endpoint tests
          - Mock Firebase Admin SDK with jest.mock('firebase-admin')
          - Mock Supabase client with jest.mock('@supabase/supabase-js')
          - Target ≥80% code coverage
          - Add npm script "test": "jest"
        </steps>
        <reference>tech-spec.md:2183-2270 (testing approach)</reference>
      </task>
      <task id="11" priority="low" ac="all">
        <title>Environment configuration and documentation</title>
        <steps>
          - Create .env.example with all required variables (see environment-variables section)
          - Add .env to .gitignore
          - Create backend/README.md with:
            - Setup instructions (npm install, configure .env, run migrations)
            - npm scripts documentation (dev, build, test, db:migrate, generate:demo-crews)
            - Troubleshooting section (common Firebase/Supabase connection errors)
        </steps>
      </task>
    </implementation-tasks>

    <code-examples>
      <example name="Express Server Setup">
        <file>backend/src/server.ts</file>
        <code language="typescript"><![CDATA[
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import healthRoutes from './routes/health';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors({ origin: process.env.FRONTEND_URL || 'http://localhost:5173' }));
app.use(express.json());

// Request logging
app.use((req, res, next) => {
  console.log(`${req.method} ${req.path}`);
  next();
});

// Routes
app.use('/api', healthRoutes);

// Error handling
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Error:', err);
  res.status(500).json({ error: 'Internal server error', message: err.message });
});

// Start server
if (process.env.NODE_ENV !== 'test') {
  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
  });
}

export default app;
]]></code>
      </example>

      <example name="Firebase Admin SDK Config">
        <file>backend/src/config/firebase.ts</file>
        <code language="typescript"><![CDATA[
import admin from 'firebase-admin';

const serviceAccount = {
  projectId: process.env.FIREBASE_PROJECT_ID,
  clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
  privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
};

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount as admin.ServiceAccount),
});

export const auth = admin.auth();
export const firestore = admin.firestore();
export default admin;
]]></code>
      </example>

      <example name="Supabase Client Config">
        <file>backend/src/config/supabase.ts</file>
        <code language="typescript"><![CDATA[
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  throw new Error('Missing Supabase credentials');
}

export const supabase = createClient(supabaseUrl, supabaseServiceKey);
]]></code>
      </example>

      <example name="Auth Middleware">
        <file>backend/src/middleware/auth.ts</file>
        <code language="typescript"><![CDATA[
import { Request, Response, NextFunction } from 'express';
import { auth } from '../config/firebase';

export interface AuthRequest extends Request {
  user?: {
    uid: string;
    email?: string;
    role?: string;
  };
}

export async function authMiddleware(
  req: AuthRequest,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({ error: 'Unauthorized: Missing or invalid token' });
      return;
    }

    const token = authHeader.split('Bearer ')[1];
    const decodedToken = await auth.verifyIdToken(token);

    req.user = {
      uid: decodedToken.uid,
      email: decodedToken.email,
      role: decodedToken.role || 'crew_member', // Default role
    };

    next();
  } catch (error) {
    console.error('Auth error:', error);
    res.status(401).json({ error: 'Unauthorized: Invalid token' });
  }
}
]]></code>
      </example>

      <example name="RBAC Middleware">
        <file>backend/src/middleware/rbac.ts</file>
        <code language="typescript"><![CDATA[
import { Response, NextFunction } from 'express';
import { AuthRequest } from './auth';

const ROLE_HIERARCHY = {
  admin: ['admin', 'manager', 'foreman', 'crew_member'],
  manager: ['manager', 'foreman', 'crew_member'],
  foreman: ['foreman', 'crew_member'],
  crew_member: ['crew_member'],
};

export function requireRole(requiredRole: string) {
  return (req: AuthRequest, res: Response, next: NextFunction): void => {
    const userRole = req.user?.role;

    if (!userRole) {
      res.status(403).json({ error: 'Forbidden: No role assigned' });
      return;
    }

    const allowedRoles = ROLE_HIERARCHY[userRole as keyof typeof ROLE_HIERARCHY] || [];

    if (!allowedRoles.includes(requiredRole)) {
      res.status(403).json({
        error: 'Forbidden: Insufficient permissions',
        required: requiredRole,
        current: userRole
      });
      return;
    }

    next();
  };
}
]]></code>
      </example>

      <example name="Health Check Routes">
        <file>backend/src/routes/health.ts</file>
        <code language="typescript"><![CDATA[
import { Router } from 'express';
import { auth } from '../config/firebase';
import { supabase } from '../config/supabase';

const router = Router();

router.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString()
  });
});

router.get('/health/db', async (req, res) => {
  const status = {
    firebase: 'unknown' as 'connected' | 'error' | 'unknown',
    supabase: 'unknown' as 'connected' | 'error' | 'unknown',
  };

  // Test Firebase connection
  try {
    await auth.listUsers(1);
    status.firebase = 'connected';
  } catch (error) {
    console.error('Firebase connection error:', error);
    status.firebase = 'error';
  }

  // Test Supabase connection
  try {
    const { error } = await supabase.from('crews').select('count');
    status.supabase = error ? 'error' : 'connected';
  } catch (error) {
    console.error('Supabase connection error:', error);
    status.supabase = 'error';
  }

  const httpStatus = (status.firebase === 'connected' && status.supabase === 'connected') ? 200 : 503;
  res.status(httpStatus).json(status);
});

export default router;
]]></code>
      </example>

      <example name="Database Migration SQL">
        <file>database/migrations/001_create_payroll_schema.sql</file>
        <code language="sql"><![CDATA[
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Crews table
CREATE TABLE crews (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  foreman_id UUID,  -- Firebase user UID
  created_at TIMESTAMP DEFAULT NOW()
);

-- Project crew assignments
CREATE TABLE project_crew_assignments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  project_id UUID NOT NULL,  -- Firebase project document ID
  crew_id UUID REFERENCES crews(id) ON DELETE CASCADE,
  start_date DATE NOT NULL,
  end_date DATE,
  status TEXT DEFAULT 'active',
  created_at TIMESTAMP DEFAULT NOW()
);

-- Labor estimates
CREATE TABLE labor_estimates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  project_id UUID NOT NULL,  -- Firebase project document ID
  estimated_cost DECIMAL(10,2),
  estimated_duration INT,  -- Days
  created_at TIMESTAMP DEFAULT NOW()
);

-- CPM tasks
CREATE TABLE cpm_tasks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  estimate_id UUID REFERENCES labor_estimates(id) ON DELETE CASCADE,
  task_name TEXT NOT NULL,
  estimated_hours DECIMAL(5,2),
  dependencies TEXT[],  -- Array of task IDs
  critical_path BOOLEAN DEFAULT FALSE,
  earliest_start INT,
  latest_start INT,
  float INT,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Timesheets
CREATE TABLE timesheets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  employee_id UUID NOT NULL,  -- Firebase user UID
  project_id UUID NOT NULL,   -- Firebase project document ID
  date DATE NOT NULL,
  clock_in TIMESTAMP,
  clock_out TIMESTAMP,
  lunch_duration INT,  -- Minutes
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(employee_id, project_id, date)
);

-- Payroll records
CREATE TABLE payroll_records (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  employee_id UUID NOT NULL,  -- Firebase user UID
  date DATE NOT NULL,
  hours_worked DECIMAL(5,2),
  base_rate DECIMAL(10,2),
  base_pay DECIMAL(10,2),
  late_penalty DECIMAL(10,2) DEFAULT 0,
  long_lunch_penalty DECIMAL(10,2) DEFAULT 0,
  total_pay DECIMAL(10,2),
  status TEXT DEFAULT 'calculated',
  approved BOOLEAN DEFAULT FALSE,
  approved_by UUID,
  approved_at TIMESTAMP,
  has_anomalies BOOLEAN DEFAULT FALSE,
  anomaly_flags TEXT[],
  created_at TIMESTAMP DEFAULT NOW()
);

-- Profitability metrics
CREATE TABLE profitability_metrics (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  project_id UUID NOT NULL,  -- Firebase project document ID
  estimated_labor DECIMAL(10,2),
  actual_labor DECIMAL(10,2),
  variance DECIMAL(10,2),
  margin_percent DECIMAL(5,2),
  updated_at TIMESTAMP DEFAULT NOW()
);
]]></code>
      </example>

      <example name="Database Indexes">
        <file>database/migrations/002_create_indexes.sql</file>
        <code language="sql"><![CDATA[
-- Project crew assignments indexes
CREATE INDEX idx_assignments_project ON project_crew_assignments(project_id);
CREATE INDEX idx_assignments_crew ON project_crew_assignments(crew_id);
CREATE INDEX idx_assignments_dates ON project_crew_assignments(start_date, end_date);

-- Timesheets indexes
CREATE INDEX idx_timesheets_employee_date ON timesheets(employee_id, date);
CREATE INDEX idx_timesheets_project_date ON timesheets(project_id, date);

-- Payroll records indexes
CREATE INDEX idx_payroll_employee_date ON payroll_records(employee_id, date);
CREATE INDEX idx_payroll_status ON payroll_records(status);
CREATE INDEX idx_payroll_anomalies ON payroll_records(has_anomalies);

-- CPM tasks indexes
CREATE INDEX idx_cpm_estimate ON cpm_tasks(estimate_id);
CREATE INDEX idx_cpm_critical_path ON cpm_tasks(critical_path);

-- Profitability metrics indexes
CREATE INDEX idx_profitability_project ON profitability_metrics(project_id);
]]></code>
      </example>
    </code-examples>
  </implementation-guide>

  <testing-strategy>
    <unit-tests>
      <test-file path="tests/server.test.ts">
        <test-case>Server starts without errors</test-case>
        <test-case>CORS configured for frontend origin</test-case>
        <test-case>Error handling middleware catches errors</test-case>
      </test-file>
      <test-file path="tests/middleware/auth.test.ts">
        <test-case>Rejects requests without Authorization header (401)</test-case>
        <test-case>Rejects requests with invalid token (401)</test-case>
        <test-case>Accepts requests with valid Firebase token (200)</test-case>
        <test-case>Attaches decoded user to req.user</test-case>
      </test-file>
      <test-file path="tests/middleware/rbac.test.ts">
        <test-case>Admin can access admin-only endpoints</test-case>
        <test-case>Crew member cannot access admin endpoints (403)</test-case>
        <test-case>Role hierarchy allows admin to access all levels</test-case>
        <test-case>Returns 403 with descriptive error message</test-case>
      </test-file>
      <test-file path="tests/routes/health.test.ts">
        <test-case>GET /api/health returns 200 OK with status and timestamp</test-case>
        <test-case>GET /api/health/db returns 200 when both databases connected</test-case>
        <test-case>GET /api/health/db returns 503 when Firebase fails</test-case>
        <test-case>GET /api/health/db returns 503 when Supabase fails</test-case>
      </test-file>
    </unit-tests>
    <integration-tests>
      <note>Integration tests will be added in subsequent stories when API endpoints exist</note>
    </integration-tests>
    <coverage-target>80% minimum for all services and middleware</coverage-target>
  </testing-strategy>

  <definition-of-done>
    <checklist>
      <item>✓ Backend directory structure created</item>
      <item>✓ Express server starts on port 3000</item>
      <item>✓ Firebase Admin SDK configured and connects successfully</item>
      <item>✓ Supabase client configured and connects successfully</item>
      <item>✓ Database migrations create all 7 tables with indexes</item>
      <item>✓ Auth middleware validates Firebase tokens (401 on failure)</item>
      <item>✓ RBAC middleware enforces role permissions (403 on insufficient)</item>
      <item>✓ Health check endpoints return correct status</item>
      <item>✓ AI crew generation script creates 3 crews with 9 workers</item>
      <item>✓ All unit tests pass with ≥80% coverage</item>
      <item>✓ .env.example created with all required variables</item>
      <item>✓ backend/README.md created with setup instructions</item>
      <item>✓ No console errors or warnings during server startup</item>
      <item>✓ Code follows TypeScript strict mode conventions</item>
      <item>✓ All npm scripts work correctly (dev, test, db:migrate, generate:demo-crews)</item>
    </checklist>
  </definition-of-done>

  <related-documents>
    <document type="tech-spec" path="../tech-spec.md">
      Complete technical specification with implementation details, database schema, testing approach
    </document>
    <document type="epic" path="../epics.md">
      Epic 1 definition with all 6 stories, success criteria, dependencies
    </document>
    <document type="brownfield-docs" path="../docs/index.md">
      Existing Projective/CollabCanvas architecture and patterns
    </document>
    <document type="story" path="./story-fieldpay-integration-1.md">
      Detailed story file for Story 1.1
    </document>
  </related-documents>

  <notes>
    <note type="architecture">
      This story establishes a dual-database architecture: Firebase Firestore (existing) for projects/BOMs
      + Supabase PostgreSQL (new) for payroll data. This separation enables relational queries for payroll
      while maintaining the existing real-time Firebase setup for collaborative features.
    </note>
    <note type="security">
      Firebase Admin SDK runs server-side only. Never expose service account credentials to frontend.
      Frontend continues to use Firebase Client SDK for authentication, backend validates tokens.
    </note>
    <note type="testing">
      Backend uses Jest (not Vitest like frontend) for consistency with Node.js ecosystem.
      Both use describe/it/expect pattern for familiarity.
    </note>
    <note type="ai-generation">
      AI crew generation uses OpenAI structured output for consistent JSON format.
      Generates realistic names, roles, and rates for immediate demo capability.
    </note>
  </notes>
</story-context>
